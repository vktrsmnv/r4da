---
title: "Problem Set 3"
subtitle: "Total points: 20"
date: "2023-03-06"
---

## New Thing 1: Badges on Readme files on GitHub

![](../files/img/assignments/badges.png)

Note that this time, there are badges on your Readme files on GitHub. Their purpose is to provide you the immediate feedback about the reproducibility of your file. Please make sure that both of them are green by the deadline.

-   *Repo Contains Allowed Files Only* will be green if you only have not added the unnecessary files into the repo, such as extra copies of your `qmd` files for instance. This will ensure that I know which file to grade without asking you (since there will only be one `qmd` file to render).
-   *Document Renders to HTML* checks that your `qmd` file renders and no errors are produced. While the file may render on your machine just fine, it may not be rendering well on someone else's if you forgot to include the package to install or did not load the data for some reason or used a machine-specific (absolute) path. This will speed up the process since I will not have to ask you to fix things after the deadline has passed. This check will only run if you commit and push changes to the `problem_set.qmd` file, so it will remain grey until you have not made any changes.

## New Thing 2: Chunk Options

In this homework, we're starting to make use of chunk options. These are tools to control whether and how your code chunks are executed, i.e. how your code is evaluated and how the output appears in the rendered document (e.g., whether we want to have two plots produced in this chunk side-by-side). You can see these options in almost every code chunk in the `qmd` file. 

| Option    | Description                                                                                                                                                                                        |
|-----------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `label`   | The name of the code chunk (must be unique in the `qmd` file)                                                                                                                                      |
| `eval`    | Evaluate the code chunk (if `false`, just echos the code into the output).                                                                                                                         |
| `echo`    | Include the source code in output                                                                                                                                                                  |
| `output`  | Include the results of executing the code in the output (`true`, `false`, or `asis` to indicate that the output is raw markdown and should not have any of Quarto\'s standard enclosing markdown). |
| `warning` | Include warnings in the output.                                                                                                                                                                    |
| `error`   | Include errors in the output (note that this implies that errors executing code will not halt processing of the document).                                                                         |
| `include` | Catch all for preventing any output (code or results) from being included (e.g. `include: false` suppresses all output from the code block).                                                       |

\

This is an example of how they'd look in the file. 

```
#| label: create-turnout-example
#| eval: false
```

You will sometimes need to change the `#| eval: false` to `#| eval: true` for the chunk to evaluate. Note that even with `#| eval: false`, if you just run the chunk inside `R` (not render the document), the code inside will still be executed. 

## Background

In this problem set, you will use visualization tools to detect election manipulation. You will work with election results from parliamentary elections in two countries - Russia in 2016 and Germany in 2017. The datasets have a similar structure: they are on the lowest level possible - the polling station level, hence very many observations. In both cases, the datasets include only the proportional part, as both countries used mixed electoral systems in that year.

| Variable          | Description                                                |
|-------------------|-----------------------------------------------------|
| `dist`            | ID of the electoral district                               |
| `dist_name`       | the electoral district name, if available                  |
| `region`          | federal unit (Land in Germany, Federal Subjects in Russia) |
| `eligible_voters` | number of the voters registered to vote in this precinct   |
| `turnout_count`   | number of voters as the sum of valid and invalid ballots   |
| `valid_count`     | number of valid ballots                                    |
| `PARTY_count`     | number of votes for the party                              |

@LACASA2019e19 write:

> suppose that the fraudulent mechanism is based on adding to the ballot box of a particular polling station a large number of fake ballots for some party (so-called ballot stuffing). In this case, not only the results of the favored party will improve there, but also the turnout for that polling station will increase, hence if that fraud strategy is systematically repeated one should expect a positive correlation between results of the favored party and turnout to emerge.


Your goal would be to explore if this is the case in both Russia, a country infamous for its electoral manipulation history, and Germany, an example of clean elections.

## Task 0: Update the Name in YAML

## Task 1: Loading the Data (1 point)

This time you will be working with two datasets.

Please load the two datasets from the *data* folder using the `readr` package and the function `read_csv()`. Store the data in objects `russia` and `germany`. Apply `clean_names()` to each dataset to clean the variable names.

## Task 2: Overview of the Dataset (3 points)

Describe the dataset. Please answer the following questions in text and with the code where it is needed. I provide you with some code that generates the tables of descriptive statistics for each dataset.

| *Note that you need to change the `#| eval: false` to `#| eval: true` or remove that line completely, as other wise the chunk will not be evaluated.*

-   How many variables are there in each dataset? How many observations (i.e. polling stations) are included in the data?

-   Describe the distributions of the variables in the bales below. What can you observe regarding their distributions?

-   Add comments (with `#`) to each line of the code in the chunk below to describe what it does. You can run the code line-by-line to see the output and figure out the answer.


## Task 3: Prepare the Variables for Plotting (5 points)

Since we are interested in the correlation between voter turnout and party vote shares, we need to obtain these variables first.

Given that $\text{Vote Share}_A=\frac{\text{Vote Count}_A}{\text{Turnout Count}}$, we will need to create a variable for vote share from the `PARTY_count` and `turnout_count` variables.

This is how we would create a new variable for SPD vote share in Germany.

| *Note that you need to change the `#| eval: false` to `#| eval: true` or remove that line completely, as other wise the chunk will not be evaluated when rendering the file.*


3.1. Create the variables for turnout for all other parties in the dataset for Germany. What you will need to do it copy the code from above and change the name of the new variable and the count variable.

```{r}
#| label: create-turnout-germany
```

3.2. Do the same for Russia for the three parties in the dataset. `ur` stands for *United Russia*, the ruling party in the regime, `communists` are the main (parliamentary) opponents to the ruling party. `socdem` are the Social Democrats, a party that is essentially a satellite of the ruling party.

```{r}
#| label: create-turnout-russia
```

3.3. Work with the CDU/CSU and Greens party vote shares in Germany. Plot the distributions of each of the variables (not their relationship!). It is up to you *how* to visualize the distributions. Make sure that your plots contain the information about the distribution of the variable, i.e. its shape and central tendency, as well as the raw data (e.g. with `geom_point()` or `geom_rug()`). Describe the distributions in 2-3 sentences.

```{r}
#| label: plot-voteshare-germany
#| layout-ncol: 2
```

3.4. Now look at the distribution of the vote share of *United Russia*. Describe the distributions in 2-3 sentences.

```{r}
#| label: plot-voteshare-russia
#| layout-ncol: 2
```

## Task 4: Explore the relationship between turnout and vote share (8 points)

Now you finally plot the joint distribution of voter turnout and vote shares. Start with Germany and plot the voteshares of CDU/CSU over the turnout.

4.1. Make a scatterplot and try to account for overplotting. Store the plot to object `cdu_turnout_plot` in the environment. Print it (i.e. type the name of the object at the end of the chunk). What can you observe from this plot?

```{r}
#| label: plot-cdu-turnout-scatter
```

4.2. Estimate the covariance, correlation, and linear regression for these two variables. Interpret the numbers in 2-3 sentences.

```{r}
#| label: association-measures-germany
```

4.3. Add regression line to the `cdu_turnout_plot` object. Do *not* use the `geom_smooth()` but rather use `geom_abline()`.


```{r}
#| label: regression-line-germany
```

Now work with Russian data and the variable for the vote share of the *United Russia* and turnout.

4.4. Make a scatterplot and try to account for overplotting. Add regression line to this plot with `geom_smooth()`. What differences if any do you observe in comparison to German case?


```{r}
#| label: plot-ur-turnout-scatter
```

4.5. Estimate the covariance, correlation, and linear regression for the vote share of the *United Russia* and turnout variables. Interpret the numbers in 2-3 sentences.


```{r}
#| label: association-measures-russia
```

## Task 5: Make 2D Plots for Joint Densities (3 points)

Now you will try to recreate a plot like this from @Klimek2012:

![](../files/img/assignments/pnas.png){width="340"}

> Election fingerprints. Two-dimensional histograms of the number of units for a given voter turnout (x axis) and the percentage of votes (y axis) for the winning party (or candidate) in recent elections from different countries (Austria, Canada, Czech Republic, Finland, France, Poland, Romania, Russia 2011, Russia 2012, Spain, Switzerland, and Uganda) are shown. Color represents the number of units with corresponding vote and turnout numbers. The units usually cluster around a given turnout and vote percentage level. In Uganda and Russia, these clusters are smeared out to the upper right region of the plots, reaching a second peak at a 100% turnout and 100% of votes (red circles). In Canada, there are clusters around two different vote values, corresponding to the Québécois and English Canada (SI Text). In Finland, the main cluster is smeared out into two directions (indicative of voter mobilization because of controversies surrounding the True Finns).

Using an appropriate `geom`, make the plots like this for *CDU* in Germany and *United Russia* in Russia. Do you observe the same patters as the authors of this paper find? Is there anything else you find interesting about the empirical picture?


## Task 6: Further Insights (Optional, up to 3 additional points)

Some scholars, e.g. @Jimenez2017, argue that there are differences between vote results in small and large polling stations:

> small polling stations are more susceptible to voter rigging because it is easier to identify opposing individuals, there are fewer eyewitnesses, and interested parties might reasonably expect fewer visits from election observers.

Let's see if it is the case!

First, let's say a large polling station will be the one with at least 500 people assign to it.

6.1. Create a new variable `small` using `mutate()` to show that if there are more than 500 eligible voters in the polling station, it is "Large" and "Small" otherwise. This variable is already present in the dataset. I created this variable with an `if_else()` command, which follows this template:

`if_else(CONDITION, VALUE_IF_TRUE, VALUE_IF_ELSE)`

| *Note that you need to change the `#| eval: false` to `#| eval: true` or remove that line completely, as otherwise the chunk will not be evaluated when rendering the file.*

6.2. Now let's make the very same heat maps as before, but facet them over the small variable (use `facet_wrap`, see the code below). Make the heat maps for `ur_share` in Russia and `cdu_share` in Germany. What can you say about the small-large polling station distinction now?

| *Note that you need to change the `#| eval: false` to `#| eval: true` or remove that line completely, as other wise the chunk will not be evaluated when rendering the file.*


## Task 7: Final Steps

-   Style your code with `styler` addin: https://styler.r-lib.org/.
-   Render the final version of your document into PDF.
-   Check that your PDF looks reasonable (i.e. all code is visible, all the text is readable). 
-   Commit and push the latest version of your file to GitHub.
